{"ast":null,"code":"// nanoid è uno strumento di redux toolkit per generare id random\nimport { createSlice, nanoid, createAsyncThunk, createSelector, createEntityAdapter } from \"@reduxjs/toolkit\";\nimport axios from \"axios\";\nimport { sub } from \"date-fns\";\nconst POSTS_URL = 'https://jsonplaceholder.typicode.com/posts';\nexport let Status; // ENTITY ADAPTER CON TYPESCRIPT\n\n(function (Status) {\n  Status[\"IDLE\"] = \"idle\";\n  Status[\"LOADING\"] = \"loading\";\n  Status[\"SUCCEDED\"] = \"succeded\";\n  Status[\"FAILED\"] = \"failed\";\n  Status[\"PENDING\"] = \"pending\";\n})(Status || (Status = {}));\n\nconst postsAdapter = createEntityAdapter({\n  sortComparer: (a, b) => b.date.localeCompare(a.date)\n});\n// State iniziale (simile al reducer) - implementato con Adapter\nconst initialState = postsAdapter.getInitialState({\n  // Rimosso poiché con l'adapter non serve inizializzare ad array vuoto\n  // posts: [],\n  status: Status.IDLE,\n  // 'idle' | 'loading' | 'succeded' | 'failed'\n  error: null,\n  // Il count è solo per testare le ottimizzazioni ma è inutile per il blog\n  count: 0\n}); // Fetch per prendere i post (<Post[]> è il return della funzione)\n\nexport const fetchPosts = createAsyncThunk('posts/fetchPosts', async () => {\n  const response = await axios.get(POSTS_URL);\n  const data = response.data;\n  return [...data];\n}); // Quando c'è un parametro va inserito per forza oltre al tipo di ritorno, il tipo del primo argomento che riceve la funzione (initialPost)\n\nexport const addNewPost = createAsyncThunk('posts/addNewPost', async initialPost => {\n  const response = await axios.post(POSTS_URL, initialPost);\n  const data = response.data;\n  return { ...data\n  };\n}); // Update post (il thunk ritorna un post e prende initialEdit come param)\n\nexport const updatePost = createAsyncThunk('posts/updatePost', async initialPost => {\n  const {\n    id\n  } = initialPost;\n  const response = await axios.put(`${POSTS_URL}/${id}`, initialPost);\n  const data = response.data;\n  return { ...data\n  };\n}); // Delete post (ritorna l'oggetto stesso oppure una stringa)\n\nexport const deletePost = createAsyncThunk('post/deletePost', async initialPost => {\n  const {\n    id\n  } = initialPost;\n  const response = await axios.delete(`${POSTS_URL}/${id}`); // json placeholder con le request delete non ritorna l'id come dovrebbe fare una rest api, quindi si ritorna l'oggetto stesso in questo caso\n\n  if ((response === null || response === void 0 ? void 0 : response.status) === 200) return initialPost;\n  return `${response === null || response === void 0 ? void 0 : response.status}: ${response === null || response === void 0 ? void 0 : response.statusText}`;\n}); // Export slice (oggetto che ha un nome, uno state iniziale, e i reducers che compieranno varie azioni)\n// i reducer e extraReducer qui sotto saranno runnati SOLO nel createSlice in questo caso postsSlice\n\nconst postsSlice = createSlice({\n  name: 'posts',\n  // TIPIZZAZIONE PER ADAPTER\n  initialState: postsAdapter.getInitialState(),\n  reducers: {\n    // questo postAdded ha un reducer e una prepare che è una funzione callback\n    postAdded: {\n      reducer(state, action) {// Action sarà l'azione dispatchata\n        // Payload corrisponderà alle values inserite nelle form\n        // IMPORTANTE: si può usare il push invece di useState solo perché redux toolkit usa una sintassi js,\n        // in tutti gli altri file non-slice però si deve ancora usare useState o l'hook che fa a quel caso\n        // SENZA ADAPTER\n        // state.posts.push(action.payload);\n      },\n\n      prepare(title, body, userId) {\n        return {\n          payload: {\n            id: nanoid(),\n            title,\n            body,\n            userId,\n            date: new Date().toISOString(),\n            reactions: {\n              thumbsUp: 0,\n              wow: 0,\n              heart: 0,\n              rocket: 0,\n              coffee: 0\n            }\n          }\n        };\n      }\n\n    },\n\n    reactionAdded(state, action) {\n      const {\n        postId,\n        reaction\n      } = action.payload; // Cambiato per via dell'adapter\n      // const existingPost = state.posts.find(post => post.id === postId)\n\n      const existingPost = state.entities[postId];\n\n      if (existingPost) {\n        existingPost.reactions[reaction]++;\n      }\n    },\n\n    // Non prende nessuna action in quanto agisce sul count dello state senza bisogno di parametri\n    increaseCount(state) {\n      state.count = state.count + 1;\n    }\n\n  },\n\n  extraReducers(builder) {\n    // Gestione di tutti i casi status tramite builder\n    builder.addCase(fetchPosts.pending, (state, action) => {\n      state.status = Status.LOADING;\n    }).addCase(fetchPosts.fulfilled, (state, action) => {\n      state.status = Status.SUCCEDED; // Data e reazioni\n\n      let min = 1;\n      const loadedPosts = action.payload.map(post => {\n        post.date = sub(new Date(), {\n          minutes: min++\n        }).toISOString();\n        post.reactions = {\n          thumbsUp: 0,\n          wow: 0,\n          heart: 0,\n          rocket: 0,\n          coffee: 0\n        };\n        return post;\n      }); // Aggiunta di ogni post fetchato nell'array (cambiato in seguito all'adapter)\n      // state.posts = state.posts.concat(loadedPosts);\n\n      postsAdapter.upsertMany(state, loadedPosts);\n    }).addCase(fetchPosts.rejected, (state, action) => {\n      state.status = Status.FAILED;\n      state.error = action.error.message;\n    }) // Case per il nuovo post\n    .addCase(addNewPost.fulfilled, (state, action) => {\n      // Fix per api post id non accurati\n      // Assegnazione id manuale (non sarebbe necessaria se l'api ritornasse id accurati)\n      const sortedPosts = state.posts.sort((a, b) => {\n        if (a.id > b.id) return 1;\n        if (a.id < b.id) return -1;\n        return 0;\n      });\n      action.payload.id = sortedPosts[sortedPosts.length - 1].id + 1;\n      action.payload.userId = Number(action.payload.userId);\n      action.payload.date = new Date().toISOString();\n      action.payload.reactions = {\n        thumbsUp: 0,\n        wow: 0,\n        heart: 0,\n        rocket: 0,\n        coffee: 0\n      };\n      state.posts.push(action.payload);\n    }) // Case per edit post\n    .addCase(updatePost.fulfilled, (state, action) => {\n      var _action$payload;\n\n      // Se il payload non ha alcun id allora non verrà completato l'update\n      if (!((_action$payload = action.payload) !== null && _action$payload !== void 0 && _action$payload.id)) {\n        console.log('Update could not complete');\n        console.log(action.payload);\n        return;\n      }\n\n      const {\n        id\n      } = action.payload;\n      action.payload.date = new Date().toISOString();\n      const posts = state.posts.filter(post => post.id !== id);\n      state.posts = [...posts, action.payload];\n    }).addCase(deletePost.fulfilled, (state, action) => {\n      // Controllo runtime per debug nel caso si torni la stringa con il codice status\n      if (typeof action.payload !== 'string') {\n        var _action$payload2;\n\n        if (!((_action$payload2 = action.payload) !== null && _action$payload2 !== void 0 && _action$payload2.id)) {\n          console.log('Delete could not complete');\n          console.log(action.payload);\n          return;\n        }\n\n        const {\n          id\n        } = action.payload;\n        const posts = state.posts.filter(post => post.id !== id); // Non si usa lo spread perché non si vuole più quel post anche nell'array originale\n\n        state.posts = posts;\n      } else {\n        console.log(action.payload);\n      }\n    });\n  }\n\n}); // https://redux-toolkit.js.org/usage/usage-with-typescript#createslice\n// In futuro se cambia initialState non avremo più un array e si dovrà cambiare state in ogni componente\n// Quindi si generalizza l'export selezionando tutti i post, così se cambiano i post si dovrà cambiare solo lo slice\n\nexport const selectAllPosts = state => state.posts.posts;\nexport const getPostStatus = state => state.posts.status;\nexport const getPostsError = state => state.posts.error; // Selettore per il test count (si deve far riferimento a state.posts perché i reducers avvengono SOLO in postsSlice altrimenti bisogna creare un altro slice)\n\nexport const selectCount = state => state.posts.count;\nexport const selectPostById = (state, postId) => state.posts.posts.find(post => post.id === postId); // Spiegazione sul createSelector su appunti o documentazione\n// In breve: prende una inputSelector e solo se questa cambia avviene la resultFunction\n// il primo inputSelector ritorna ciò che è il primo parametro della resultFunction, il secondo ritorna il secondo parametro e così via se ci fossero altri selettori\n\nexport const selectPostsByUser = createSelector( // inputSelectors (come array)\n[selectAllPosts, (state, userId) => userId], // resultFunction\n(posts, userId) => posts.filter(post => post.userId === userId)); // Actions è la keyword per esportare le possibili azioni\n// Quando si scrive questa funzione postAdded e si crea,\n// slice genera in automatico un'azione \"creator function\" con lo stesso nome della funzione che adda i post\n// Quindi si sta esportando questa azione creator function che è creata automaticamente,\n// ed è per questo che sopra non si vede la creazione postSlice.action, è automaticamente creata\n\nexport const {\n  postAdded,\n  reactionAdded,\n  increaseCount\n} = postsSlice.actions; // Export del reducer\n\nexport default postsSlice.reducer;","map":{"version":3,"names":["createSlice","nanoid","createAsyncThunk","createSelector","createEntityAdapter","axios","sub","POSTS_URL","Status","postsAdapter","sortComparer","a","b","date","localeCompare","initialState","getInitialState","status","IDLE","error","count","fetchPosts","response","get","data","addNewPost","initialPost","post","updatePost","id","put","deletePost","delete","statusText","postsSlice","name","reducers","postAdded","reducer","state","action","prepare","title","body","userId","payload","Date","toISOString","reactions","thumbsUp","wow","heart","rocket","coffee","reactionAdded","postId","reaction","existingPost","entities","increaseCount","extraReducers","builder","addCase","pending","LOADING","fulfilled","SUCCEDED","min","loadedPosts","map","minutes","upsertMany","rejected","FAILED","message","sortedPosts","posts","sort","length","Number","push","console","log","filter","selectAllPosts","getPostStatus","getPostsError","selectCount","selectPostById","find","selectPostsByUser","actions"],"sources":["/Users/emanuelecardone/Desktop/Corsi /Redux/Esempi/react-redux-typescript-async/src/features/posts/postsSlice.tsx"],"sourcesContent":["// nanoid è uno strumento di redux toolkit per generare id random\nimport { \n    createSlice, \n    nanoid, \n    PayloadAction, \n    createAsyncThunk, \n    createSelector, \n    createEntityAdapter \n} from \"@reduxjs/toolkit\";\nimport { RootState } from \"../../app/store\";\nimport axios from \"axios\";\nimport {sub} from \"date-fns\";\n\nconst POSTS_URL = 'https://jsonplaceholder.typicode.com/posts';\n\nexport type Reactions = {\n    thumbsUp: number;\n    wow: number;\n    heart: number;\n    rocket: number;\n    coffee: number;\n}\n\nexport type Post = {\n    id: string; \n    title: string; \n    body: string;\n    userId: string | number;\n    date: string;\n    reactions: Reactions;\n}\n\n// Aggiunta post\ntype InitialPost = {\n    title: string;\n    body: string;\n    userId: string | number;\n}\n\n// Modifica post\ntype InitialEdit = {\n    id: string;\n    title: string;\n    body: string;\n    userId: string | number;\n    reactions: Reactions;\n}\n\n// Delete post \ntype InitialDelete = {\n    id: string;\n}\n\n// Custom type per payload action\ntype PostsPayload = PayloadAction<Post>\n\n// Custom type per reactions\ntype ReactionsPayload = PayloadAction<{\n    postId: string;\n    reaction: keyof Reactions;\n}>\n\nexport enum Status {\n    IDLE = 'idle',\n    LOADING = 'loading',\n    SUCCEDED = 'succeded',\n    FAILED = 'failed',\n    PENDING = 'pending'\n}\n\n// ENTITY ADAPTER CON TYPESCRIPT\nconst postsAdapter = createEntityAdapter<Post>({\n    sortComparer: (a, b) => b.date.localeCompare(a.date)\n});\n\ntype InitialState = {\n    // Rimosso poiché con l'adapter non serve inizializzare ad array vuoto\n    // posts: Post[];\n    status: Status;\n    error: unknown | Error;\n    count: number;\n}\n\n// State iniziale (simile al reducer) - implementato con Adapter\nconst initialState: InitialState = postsAdapter.getInitialState({\n    // Rimosso poiché con l'adapter non serve inizializzare ad array vuoto\n    // posts: [],\n    status: Status.IDLE, // 'idle' | 'loading' | 'succeded' | 'failed'\n    error: null,\n    // Il count è solo per testare le ottimizzazioni ma è inutile per il blog\n    count: 0\n}) \n\n// Fetch per prendere i post (<Post[]> è il return della funzione)\nexport const fetchPosts = createAsyncThunk<Post[]>('posts/fetchPosts', async () => {\n    const response = await axios.get(POSTS_URL);\n    const data: Post[] = response.data;\n    return [...data];\n})\n\n// Quando c'è un parametro va inserito per forza oltre al tipo di ritorno, il tipo del primo argomento che riceve la funzione (initialPost)\nexport const addNewPost = createAsyncThunk<Post, InitialPost>('posts/addNewPost', async (initialPost) => {\n    const response = await axios.post(POSTS_URL, initialPost);\n    const data: Post = response.data;\n    return {...data};\n});\n\n// Update post (il thunk ritorna un post e prende initialEdit come param)\nexport const updatePost = createAsyncThunk<Post, InitialEdit>('posts/updatePost', async (initialPost) => {\n    const { id } = initialPost; \n    const response = await axios.put(`${POSTS_URL}/${id}`, initialPost);\n    const data: Post = response.data;\n    return {...data};\n});\n\n// Delete post (ritorna l'oggetto stesso oppure una stringa)\nexport const deletePost = createAsyncThunk<InitialDelete | string, InitialDelete>('post/deletePost', async (initialPost) => {\n    const { id } = initialPost;\n    const response = await axios.delete(`${POSTS_URL}/${id}`);\n    // json placeholder con le request delete non ritorna l'id come dovrebbe fare una rest api, quindi si ritorna l'oggetto stesso in questo caso\n    if(response?.status === 200) return initialPost;\n    return `${response?.status}: ${response?.statusText}`;\n});\n\n// Export slice (oggetto che ha un nome, uno state iniziale, e i reducers che compieranno varie azioni)\n// i reducer e extraReducer qui sotto saranno runnati SOLO nel createSlice in questo caso postsSlice\nconst postsSlice = createSlice({\n    name: 'posts',\n    // TIPIZZAZIONE PER ADAPTER\n    initialState: postsAdapter.getInitialState(),\n    reducers: {\n        // questo postAdded ha un reducer e una prepare che è una funzione callback\n        postAdded:{\n            reducer(state, action: PayloadAction<{posts: Post[]}>){\n                // Action sarà l'azione dispatchata\n                // Payload corrisponderà alle values inserite nelle form\n                // IMPORTANTE: si può usare il push invece di useState solo perché redux toolkit usa una sintassi js,\n                    // in tutti gli altri file non-slice però si deve ancora usare useState o l'hook che fa a quel caso\n                // SENZA ADAPTER\n                // state.posts.push(action.payload);\n            },\n            prepare(title: string, body: string, userId: string | number){\n                return {\n                    payload: {\n                        id: nanoid(),\n                        title,\n                        body,\n                        userId,\n                        date: new Date().toISOString(),\n                        reactions: {\n                            thumbsUp: 0,\n                            wow: 0,\n                            heart: 0,\n                            rocket: 0,\n                            coffee: 0\n                        }\n                    }\n                }\n            }\n        },\n        reactionAdded(state, action: ReactionsPayload){\n            const {postId, reaction} = action.payload;\n            // Cambiato per via dell'adapter\n            // const existingPost = state.posts.find(post => post.id === postId)\n            const existingPost = state.entities[postId];\n            if(existingPost){\n                existingPost.reactions[reaction]++;\n            }\n        },\n        // Non prende nessuna action in quanto agisce sul count dello state senza bisogno di parametri\n        increaseCount(state){\n            state.count = state.count +1;\n        }\n    },\n    extraReducers(builder){\n        // Gestione di tutti i casi status tramite builder\n        builder\n            .addCase(fetchPosts.pending, (state, action) => {\n                state.status = Status.LOADING;\n            })\n            .addCase(fetchPosts.fulfilled, (state, action) => {\n                state.status = Status.SUCCEDED;\n                // Data e reazioni\n                let min = 1;\n                const loadedPosts = action.payload.map((post: Post) => {\n                    post.date = sub(new Date(), {minutes: min++}).toISOString();\n                    post.reactions = {\n                        thumbsUp: 0,\n                        wow: 0,\n                        heart: 0,\n                        rocket: 0,\n                        coffee: 0\n                    }\n                    return post;\n                });\n\n                // Aggiunta di ogni post fetchato nell'array (cambiato in seguito all'adapter)\n                // state.posts = state.posts.concat(loadedPosts);\n                postsAdapter.upsertMany(state, loadedPosts);\n            })\n            .addCase(fetchPosts.rejected, (state, action) => {\n                state.status = Status.FAILED;\n                state.error = action.error.message;\n            })\n            // Case per il nuovo post\n            .addCase(addNewPost.fulfilled, (state, action) => {\n                \n                // Fix per api post id non accurati\n                // Assegnazione id manuale (non sarebbe necessaria se l'api ritornasse id accurati)\n                const sortedPosts = state.posts.sort((a: Post, b: Post) => {\n                    if(a.id > b.id) return 1;\n                    if(a.id < b.id) return -1;\n                    return 0;\n                });\n                action.payload.id = sortedPosts[sortedPosts.length - 1].id +1;\n\n                action.payload.userId = Number(action.payload.userId);\n                action.payload.date = new Date().toISOString();\n                action.payload.reactions = {\n                    thumbsUp: 0,\n                    wow: 0,\n                    heart: 0,\n                    rocket: 0,\n                    coffee: 0\n                }\n                state.posts.push(action.payload);\n            })\n            // Case per edit post\n            .addCase(updatePost.fulfilled, (state, action) => {\n                // Se il payload non ha alcun id allora non verrà completato l'update\n                if(!action.payload?.id){\n                    console.log('Update could not complete');\n                    console.log(action.payload);\n                    return;\n                }\n                const { id } = action.payload;\n                action.payload.date = new Date().toISOString();\n                const posts = state.posts.filter(post => post.id !== id);\n                state.posts = [...posts, action.payload];\n            })\n            .addCase(deletePost.fulfilled, (state,action) => {\n                // Controllo runtime per debug nel caso si torni la stringa con il codice status\n                if(typeof action.payload !== 'string'){\n                    if(!action.payload?.id){\n                        console.log('Delete could not complete');\n                        console.log(action.payload);\n                        return;\n                    }\n                    const { id } = action.payload;\n                    const posts = state.posts.filter(post => post.id !== id);\n                    // Non si usa lo spread perché non si vuole più quel post anche nell'array originale\n                    state.posts = posts;\n                } else{\n                    console.log(action.payload);\n                }\n            });\n    }\n});\n\n// https://redux-toolkit.js.org/usage/usage-with-typescript#createslice\n\n// In futuro se cambia initialState non avremo più un array e si dovrà cambiare state in ogni componente\n// Quindi si generalizza l'export selezionando tutti i post, così se cambiano i post si dovrà cambiare solo lo slice\nexport const selectAllPosts = (state: RootState) => state.posts.posts;\nexport const getPostStatus = (state: RootState) => state.posts.status;\nexport const getPostsError = (state: RootState) => state.posts.error;\n\n// Selettore per il test count (si deve far riferimento a state.posts perché i reducers avvengono SOLO in postsSlice altrimenti bisogna creare un altro slice)\nexport const selectCount = (state: RootState) => state.posts.count;\n\nexport const selectPostById = (state: RootState, postId: number | string) => state.posts.posts.find(post => post.id === postId);\n\n// Spiegazione sul createSelector su appunti o documentazione\n// In breve: prende una inputSelector e solo se questa cambia avviene la resultFunction\n    // il primo inputSelector ritorna ciò che è il primo parametro della resultFunction, il secondo ritorna il secondo parametro e così via se ci fossero altri selettori\nexport const selectPostsByUser = createSelector(\n    // inputSelectors (come array)\n    [\n        selectAllPosts, \n        (state, userId) => userId\n    ],\n    // resultFunction\n    (posts, userId) => posts.filter(post => post.userId === userId)\n);\n\n// Actions è la keyword per esportare le possibili azioni\n// Quando si scrive questa funzione postAdded e si crea,\n   // slice genera in automatico un'azione \"creator function\" con lo stesso nome della funzione che adda i post\n// Quindi si sta esportando questa azione creator function che è creata automaticamente,\n    // ed è per questo che sopra non si vede la creazione postSlice.action, è automaticamente creata\n   export const { postAdded, reactionAdded, increaseCount } = postsSlice.actions;\n\n// Export del reducer\nexport default postsSlice.reducer;"],"mappings":"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"},"metadata":{},"sourceType":"module"}