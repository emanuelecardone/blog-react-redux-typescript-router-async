{"ast":null,"code":"// nanoid è uno strumento di redux toolkit per generare id random\nimport { createSlice, nanoid, createAsyncThunk, createSelector } from \"@reduxjs/toolkit\";\nimport axios from \"axios\";\nimport { sub } from \"date-fns\";\nconst POSTS_URL = 'https://jsonplaceholder.typicode.com/posts';\nexport let Status;\n\n(function (Status) {\n  Status[\"IDLE\"] = \"idle\";\n  Status[\"LOADING\"] = \"loading\";\n  Status[\"SUCCEDED\"] = \"succeded\";\n  Status[\"FAILED\"] = \"failed\";\n  Status[\"PENDING\"] = \"pending\";\n})(Status || (Status = {}));\n\n// State iniziale (simile al reducer)\nconst initialState = {\n  posts: [],\n  status: Status.IDLE,\n  // 'idle' | 'loading' | 'succeded' | 'failed'\n  error: null,\n  // Il count è solo per testare le ottimizzazioni ma è inutile per il blog\n  count: 0\n}; // Fetch per prendere i post (<Post[]> è il return della funzione)\n\nexport const fetchPosts = createAsyncThunk('posts/fetchPosts', async () => {\n  const response = await axios.get(POSTS_URL);\n  const data = response.data;\n  return [...data];\n}); // Quando c'è un parametro va inserito per forza oltre al tipo di ritorno, il tipo del primo argomento che riceve la funzione (initialPost)\n\nexport const addNewPost = createAsyncThunk('posts/addNewPost', async initialPost => {\n  const response = await axios.post(POSTS_URL, initialPost);\n  const data = response.data;\n  return { ...data\n  };\n}); // Update post (il thunk ritorna un post e prende initialEdit come param)\n\nexport const updatePost = createAsyncThunk('posts/updatePost', async initialPost => {\n  const {\n    id\n  } = initialPost;\n  const response = await axios.put(`${POSTS_URL}/${id}`, initialPost);\n  const data = response.data;\n  return { ...data\n  };\n}); // Delete post (ritorna l'oggetto stesso oppure una stringa)\n\nexport const deletePost = createAsyncThunk('post/deletePost', async initialPost => {\n  const {\n    id\n  } = initialPost;\n  const response = await axios.delete(`${POSTS_URL}/${id}`); // json placeholder con le request delete non ritorna l'id come dovrebbe fare una rest api, quindi si ritorna l'oggetto stesso in questo caso\n\n  if ((response === null || response === void 0 ? void 0 : response.status) === 200) return initialPost;\n  return `${response === null || response === void 0 ? void 0 : response.status}: ${response === null || response === void 0 ? void 0 : response.statusText}`;\n}); // Export slice (oggetto che ha un nome, uno state iniziale, e i reducers che compieranno varie azioni)\n\nconst postsSlice = createSlice({\n  name: 'posts',\n  initialState,\n  reducers: {\n    // questo postAdded ha un reducer e una prepare che è una funzione callback\n    postAdded: {\n      reducer(state, action) {\n        // Action sarà l'azione dispatchata\n        // Payload corrisponderà alle values inserite nelle form\n        // IMPORTANTE: si può usare il push invece di useState solo perché redux toolkit usa una sintassi js,\n        // in tutti gli altri file non-slice però si deve ancora usare useState o l'hook che fa a quel caso\n        state.posts.push(action.payload);\n      },\n\n      prepare(title, body, userId) {\n        return {\n          payload: {\n            id: nanoid(),\n            title,\n            body,\n            userId,\n            date: new Date().toISOString(),\n            reactions: {\n              thumbsUp: 0,\n              wow: 0,\n              heart: 0,\n              rocket: 0,\n              coffee: 0\n            }\n          }\n        };\n      }\n\n    },\n\n    reactionAdded(state, action) {\n      const {\n        postId,\n        reaction\n      } = action.payload;\n      const existingPost = state.posts.find(post => post.id === postId);\n\n      if (existingPost) {\n        existingPost.reactions[reaction]++;\n      }\n    },\n\n    increaseCount(state, action) {\n      state.count = state.count + 1;\n    }\n\n  },\n\n  extraReducers(builder) {\n    // Gestione di tutti i casi status tramite builder\n    builder.addCase(fetchPosts.pending, (state, action) => {\n      state.status = Status.LOADING;\n    }).addCase(fetchPosts.fulfilled, (state, action) => {\n      state.status = Status.SUCCEDED; // Data e reazioni\n\n      let min = 1;\n      const loadedPosts = action.payload.map(post => {\n        post.date = sub(new Date(), {\n          minutes: min++\n        }).toISOString();\n        post.reactions = {\n          thumbsUp: 0,\n          wow: 0,\n          heart: 0,\n          rocket: 0,\n          coffee: 0\n        };\n        return post;\n      }); // Aggiunta di ogni post fetchato nell'array\n\n      state.posts = state.posts.concat(loadedPosts);\n    }).addCase(fetchPosts.rejected, (state, action) => {\n      state.status = Status.FAILED;\n      state.error = action.error.message;\n    }) // Case per il nuovo post\n    .addCase(addNewPost.fulfilled, (state, action) => {\n      // Fix per api post id non accurati\n      // Assegnazione id manuale (non sarebbe necessaria se l'api ritornasse id accurati)\n      const sortedPosts = state.posts.sort((a, b) => {\n        if (a.id > b.id) return 1;\n        if (a.id < b.id) return -1;\n        return 0;\n      });\n      action.payload.id = sortedPosts[sortedPosts.length - 1].id + 1;\n      action.payload.userId = Number(action.payload.userId);\n      action.payload.date = new Date().toISOString();\n      action.payload.reactions = {\n        thumbsUp: 0,\n        wow: 0,\n        heart: 0,\n        rocket: 0,\n        coffee: 0\n      };\n      state.posts.push(action.payload);\n    }) // Case per edit post\n    .addCase(updatePost.fulfilled, (state, action) => {\n      var _action$payload;\n\n      // Se il payload non ha alcun id allora non verrà completato l'update\n      if (!((_action$payload = action.payload) !== null && _action$payload !== void 0 && _action$payload.id)) {\n        console.log('Update could not complete');\n        console.log(action.payload);\n        return;\n      }\n\n      const {\n        id\n      } = action.payload;\n      action.payload.date = new Date().toISOString();\n      const posts = state.posts.filter(post => post.id !== id);\n      state.posts = [...posts, action.payload];\n    }).addCase(deletePost.fulfilled, (state, action) => {\n      // Controllo runtime per debug nel caso si torni la stringa con il codice status\n      if (typeof action.payload !== 'string') {\n        var _action$payload2;\n\n        if (!((_action$payload2 = action.payload) !== null && _action$payload2 !== void 0 && _action$payload2.id)) {\n          console.log('Delete could not complete');\n          console.log(action.payload);\n          return;\n        }\n\n        const {\n          id\n        } = action.payload;\n        const posts = state.posts.filter(post => post.id !== id); // Non si usa lo spread perché non si vuole più quel post anche nell'array originale\n\n        state.posts = posts;\n      } else {\n        console.log(action.payload);\n      }\n    });\n  }\n\n}); // https://redux-toolkit.js.org/usage/usage-with-typescript#createslice\n// In futuro se cambia initialState non avremo più un array e si dovrà cambiare state in ogni componente\n// Quindi si generalizza l'export selezionando tutti i post, così se cambiano i post si dovrà cambiare solo lo slice\n\nexport const selectAllPosts = state => state.posts.posts;\nexport const getPostStatus = state => state.posts.status;\nexport const getPostsError = state => state.posts.error;\nexport const selectPostById = (state, postId) => state.posts.posts.find(post => post.id === postId); // Spiegazione sul createSelector su appunti o documentazione\n// In breve: prende una inputSelector e solo se questa cambia avviene la resultFunction\n\nexport const selectPostsByUser = createSelector( // inputSelectors\n[selectAllPosts, (state, userId) => userId], // resultFunction\n(posts, userId) => posts.filter(post => post.userId === userId)); // Actions è la keyword per esportare le possibili azioni\n// Quando si scrive questa funzione postAdded e si crea,\n// slice genera in automatico un'azione \"creator function\" con lo stesso nome della funzione che adda i post\n// Quindi si sta esportando questa azione creator function che è creata automaticamente,\n// ed è per questo che sopra non si vede la creazione postSlice.action, è automaticamente creata\n\nexport const {\n  postAdded,\n  reactionAdded\n} = postsSlice.actions; // Export del reducer\n\nexport default postsSlice.reducer;","map":{"version":3,"names":["createSlice","nanoid","createAsyncThunk","createSelector","axios","sub","POSTS_URL","Status","initialState","posts","status","IDLE","error","count","fetchPosts","response","get","data","addNewPost","initialPost","post","updatePost","id","put","deletePost","delete","statusText","postsSlice","name","reducers","postAdded","reducer","state","action","push","payload","prepare","title","body","userId","date","Date","toISOString","reactions","thumbsUp","wow","heart","rocket","coffee","reactionAdded","postId","reaction","existingPost","find","increaseCount","extraReducers","builder","addCase","pending","LOADING","fulfilled","SUCCEDED","min","loadedPosts","map","minutes","concat","rejected","FAILED","message","sortedPosts","sort","a","b","length","Number","console","log","filter","selectAllPosts","getPostStatus","getPostsError","selectPostById","selectPostsByUser","actions"],"sources":["/Users/emanuelecardone/Desktop/Corsi /Redux/Esempi/react-redux-typescript-async/src/features/posts/postsSlice.tsx"],"sourcesContent":["// nanoid è uno strumento di redux toolkit per generare id random\nimport { createSlice, nanoid, PayloadAction, createAsyncThunk, createSelector } from \"@reduxjs/toolkit\";\nimport { RootState } from \"../../app/store\";\nimport axios from \"axios\";\nimport {sub} from \"date-fns\";\n\nconst POSTS_URL = 'https://jsonplaceholder.typicode.com/posts';\n\nexport type Reactions = {\n    thumbsUp: number;\n    wow: number;\n    heart: number;\n    rocket: number;\n    coffee: number;\n}\n\nexport type Post = {\n    id: string; \n    title: string; \n    body: string;\n    userId: string | number;\n    date: string;\n    reactions: Reactions;\n}\n\n// Aggiunta post\ntype InitialPost = {\n    title: string;\n    body: string;\n    userId: string | number;\n}\n\n// Modifica post\ntype InitialEdit = {\n    id: string;\n    title: string;\n    body: string;\n    userId: string | number;\n    reactions: Reactions;\n}\n\n// Delete post \ntype InitialDelete = {\n    id: string;\n}\n\n// Custom type per payload action\ntype PostsPayload = PayloadAction<Post>\n\n// Custom type per reactions\ntype ReactionsPayload = PayloadAction<{\n    postId: string;\n    reaction: keyof Reactions;\n}>\n\nexport enum Status {\n    IDLE = 'idle',\n    LOADING = 'loading',\n    SUCCEDED = 'succeded',\n    FAILED = 'failed',\n    PENDING = 'pending'\n}\n\ntype InitialState = {\n    posts: Post[];\n    status: Status;\n    error: unknown | Error;\n    count: number;\n}\n\n// State iniziale (simile al reducer)\nconst initialState: InitialState = {\n    posts: [],\n    status: Status.IDLE, // 'idle' | 'loading' | 'succeded' | 'failed'\n    error: null,\n    // Il count è solo per testare le ottimizzazioni ma è inutile per il blog\n    count: 0\n} \n\n// Fetch per prendere i post (<Post[]> è il return della funzione)\nexport const fetchPosts = createAsyncThunk<Post[]>('posts/fetchPosts', async () => {\n    const response = await axios.get(POSTS_URL);\n    const data: Post[] = response.data;\n    return [...data];\n})\n\n// Quando c'è un parametro va inserito per forza oltre al tipo di ritorno, il tipo del primo argomento che riceve la funzione (initialPost)\nexport const addNewPost = createAsyncThunk<Post, InitialPost>('posts/addNewPost', async (initialPost) => {\n    const response = await axios.post(POSTS_URL, initialPost);\n    const data: Post = response.data;\n    return {...data};\n});\n\n// Update post (il thunk ritorna un post e prende initialEdit come param)\nexport const updatePost = createAsyncThunk<Post, InitialEdit>('posts/updatePost', async (initialPost) => {\n    const { id } = initialPost; \n    const response = await axios.put(`${POSTS_URL}/${id}`, initialPost);\n    const data: Post = response.data;\n    return {...data};\n});\n\n// Delete post (ritorna l'oggetto stesso oppure una stringa)\nexport const deletePost = createAsyncThunk<InitialDelete | string, InitialDelete>('post/deletePost', async (initialPost) => {\n    const { id } = initialPost;\n    const response = await axios.delete(`${POSTS_URL}/${id}`);\n    // json placeholder con le request delete non ritorna l'id come dovrebbe fare una rest api, quindi si ritorna l'oggetto stesso in questo caso\n    if(response?.status === 200) return initialPost;\n    return `${response?.status}: ${response?.statusText}`;\n});\n\n// Export slice (oggetto che ha un nome, uno state iniziale, e i reducers che compieranno varie azioni)\nconst postsSlice = createSlice({\n    name: 'posts',\n    initialState,\n    reducers: {\n        // questo postAdded ha un reducer e una prepare che è una funzione callback\n        postAdded:{\n            reducer(state, action: PostsPayload){\n                // Action sarà l'azione dispatchata\n                // Payload corrisponderà alle values inserite nelle form\n                // IMPORTANTE: si può usare il push invece di useState solo perché redux toolkit usa una sintassi js,\n                    // in tutti gli altri file non-slice però si deve ancora usare useState o l'hook che fa a quel caso\n                state.posts.push(action.payload);\n            },\n            prepare(title: string, body: string, userId: string | number){\n                return {\n                    payload: {\n                        id: nanoid(),\n                        title,\n                        body,\n                        userId,\n                        date: new Date().toISOString(),\n                        reactions: {\n                            thumbsUp: 0,\n                            wow: 0,\n                            heart: 0,\n                            rocket: 0,\n                            coffee: 0\n                        }\n                    }\n                }\n            }\n        },\n        reactionAdded(state, action: ReactionsPayload){\n            const {postId, reaction} = action.payload;\n            const existingPost = state.posts.find(post => post.id === postId)\n            if(existingPost){\n                existingPost.reactions[reaction]++;\n            }\n        },\n        increaseCount(state, action){\n            state.count = state.count +1;\n        }\n    },\n    extraReducers(builder){\n        // Gestione di tutti i casi status tramite builder\n        builder\n            .addCase(fetchPosts.pending, (state, action) => {\n                state.status = Status.LOADING;\n            })\n            .addCase(fetchPosts.fulfilled, (state, action) => {\n                state.status = Status.SUCCEDED;\n                // Data e reazioni\n                let min = 1;\n                const loadedPosts = action.payload.map((post: Post) => {\n                    post.date = sub(new Date(), {minutes: min++}).toISOString();\n                    post.reactions = {\n                        thumbsUp: 0,\n                        wow: 0,\n                        heart: 0,\n                        rocket: 0,\n                        coffee: 0\n                    }\n                    return post;\n                });\n\n                // Aggiunta di ogni post fetchato nell'array\n                state.posts = state.posts.concat(loadedPosts);\n            })\n            .addCase(fetchPosts.rejected, (state, action) => {\n                state.status = Status.FAILED;\n                state.error = action.error.message;\n            })\n            // Case per il nuovo post\n            .addCase(addNewPost.fulfilled, (state, action) => {\n                \n                // Fix per api post id non accurati\n                // Assegnazione id manuale (non sarebbe necessaria se l'api ritornasse id accurati)\n                const sortedPosts = state.posts.sort((a: Post, b: Post) => {\n                    if(a.id > b.id) return 1;\n                    if(a.id < b.id) return -1;\n                    return 0;\n                });\n                action.payload.id = sortedPosts[sortedPosts.length - 1].id +1;\n\n                action.payload.userId = Number(action.payload.userId);\n                action.payload.date = new Date().toISOString();\n                action.payload.reactions = {\n                    thumbsUp: 0,\n                    wow: 0,\n                    heart: 0,\n                    rocket: 0,\n                    coffee: 0\n                }\n                state.posts.push(action.payload);\n            })\n            // Case per edit post\n            .addCase(updatePost.fulfilled, (state, action) => {\n                // Se il payload non ha alcun id allora non verrà completato l'update\n                if(!action.payload?.id){\n                    console.log('Update could not complete');\n                    console.log(action.payload);\n                    return;\n                }\n                const { id } = action.payload;\n                action.payload.date = new Date().toISOString();\n                const posts = state.posts.filter(post => post.id !== id);\n                state.posts = [...posts, action.payload];\n            })\n            .addCase(deletePost.fulfilled, (state,action) => {\n                // Controllo runtime per debug nel caso si torni la stringa con il codice status\n                if(typeof action.payload !== 'string'){\n                    if(!action.payload?.id){\n                        console.log('Delete could not complete');\n                        console.log(action.payload);\n                        return;\n                    }\n                    const { id } = action.payload;\n                    const posts = state.posts.filter(post => post.id !== id);\n                    // Non si usa lo spread perché non si vuole più quel post anche nell'array originale\n                    state.posts = posts;\n                } else{\n                    console.log(action.payload);\n                }\n            });\n    }\n});\n\n// https://redux-toolkit.js.org/usage/usage-with-typescript#createslice\n\n// In futuro se cambia initialState non avremo più un array e si dovrà cambiare state in ogni componente\n// Quindi si generalizza l'export selezionando tutti i post, così se cambiano i post si dovrà cambiare solo lo slice\nexport const selectAllPosts = (state: RootState) => state.posts.posts;\nexport const getPostStatus = (state: RootState) => state.posts.status;\nexport const getPostsError = (state: RootState) => state.posts.error;\n\nexport const selectPostById = (state: RootState, postId: number | string) => state.posts.posts.find(post => post.id === postId);\n\n// Spiegazione sul createSelector su appunti o documentazione\n// In breve: prende una inputSelector e solo se questa cambia avviene la resultFunction\nexport const selectPostsByUser = createSelector(\n    // inputSelectors\n    [selectAllPosts, (state, userId) => userId],\n    // resultFunction\n    (posts, userId) => posts.filter(post => post.userId === userId)\n);\n\n// Actions è la keyword per esportare le possibili azioni\n// Quando si scrive questa funzione postAdded e si crea,\n   // slice genera in automatico un'azione \"creator function\" con lo stesso nome della funzione che adda i post\n// Quindi si sta esportando questa azione creator function che è creata automaticamente,\n    // ed è per questo che sopra non si vede la creazione postSlice.action, è automaticamente creata\n   export const { postAdded, reactionAdded } = postsSlice.actions;\n\n// Export del reducer\nexport default postsSlice.reducer;"],"mappings":"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"},"metadata":{},"sourceType":"module"}