{"ast":null,"code":"// nanoid è uno strumento di redux toolkit per generare id random\nimport { createSlice, nanoid } from \"@reduxjs/toolkit\";\n// State iniziale (simile al reducer)\nconst initialState = [{\n  id: '1',\n  title: 'Learning Redux Toolkit',\n  content: 'I\\'ve heard good things.'\n}, {\n  id: '2',\n  title: 'Slices...',\n  content: 'The more i say slice, the more i want pizza.'\n}]; // Export slice (oggetto che ha un nome, uno state iniziale, e i reducers che compieranno varie azioni)\n\nconst postsSlice = createSlice({\n  name: 'posts',\n  initialState,\n  reducers: {\n    // Qui vanno le azioni reducer \n    postAdded: {\n      reducer(state, action) {\n        // Action sarà l'azione dispatchata\n        // Payload corrisponderà alle values inserite nelle form\n        // IMPORTANTE: si può usare il push invece di useState solo perché redux toolkit usa una sintassi js,\n        // in tutti gli altri file non-slice però si deve ancora usare useState o l'hook che fa a quel caso\n        state.push(action.payload);\n      },\n\n      prepare(title, content) {\n        return {\n          payload: {\n            id: nanoid(),\n            title,\n            content\n          }\n        };\n      }\n\n    }\n  }\n}); // https://redux-toolkit.js.org/usage/usage-with-typescript#createslice\n// In futuro se cambia initialState non avremo più un array e si dovrà cambiare state in ogni componente\n// Quindi si generalizza l'export selezionando tutti i post, così se cambiano i post si dovrà cambiare solo lo slice\n\nexport const selectAllPosts = state => state.posts; // Actions è la keyword per esportare le possibili azioni\n// Quando si scrive questa funzione postAdded e si crea,\n// slice genera in automatico un'azione \"creator function\" con lo stesso nome della funzione che adda i post\n// Quindi si sta esportando questa azione creator function che è creata automaticamente,\n// ed è per questo che sopra non si vede la creazione postSlice.action, è automaticamente creata\n\nexport const {\n  postAdded\n} = postsSlice.actions; // Export del reducer\n\nexport default postsSlice.reducer;","map":{"version":3,"names":["createSlice","nanoid","initialState","id","title","content","postsSlice","name","reducers","postAdded","reducer","state","action","push","payload","prepare","selectAllPosts","posts","actions"],"sources":["/Users/emanuelecardone/Desktop/Corsi /Redux/Esempi/redux-data-flow/src/features/posts/postsSlice.tsx"],"sourcesContent":["// nanoid è uno strumento di redux toolkit per generare id random\nimport { createSlice, nanoid } from \"@reduxjs/toolkit\";\nimport { RootState } from \"../../app/store\";\nimport { act } from \"react-dom/test-utils\";\n\n// State iniziale (simile al reducer)\nconst initialState = [\n    {\n        id: '1', title: 'Learning Redux Toolkit', content: 'I\\'ve heard good things.'\n    },\n    {\n        id: '2', title: 'Slices...', content: 'The more i say slice, the more i want pizza.'\n    }\n]\n\n// Export slice (oggetto che ha un nome, uno state iniziale, e i reducers che compieranno varie azioni)\nconst postsSlice = createSlice({\n    name: 'posts',\n    initialState,\n    reducers: {\n        // Qui vanno le azioni reducer \n        postAdded:{\n            reducer(state, action){\n                // Action sarà l'azione dispatchata\n                // Payload corrisponderà alle values inserite nelle form\n                // IMPORTANTE: si può usare il push invece di useState solo perché redux toolkit usa una sintassi js,\n                    // in tutti gli altri file non-slice però si deve ancora usare useState o l'hook che fa a quel caso\n                state.push(action.payload);\n            },\n            prepare(title, content){\n                return {\n                    payload: {\n                        id: nanoid(),\n                        title,\n                        content\n                    }\n                }\n            }\n        }\n    }\n});\n\n// https://redux-toolkit.js.org/usage/usage-with-typescript#createslice\n\n// In futuro se cambia initialState non avremo più un array e si dovrà cambiare state in ogni componente\n// Quindi si generalizza l'export selezionando tutti i post, così se cambiano i post si dovrà cambiare solo lo slice\nexport const selectAllPosts = (state: RootState) => state.posts;\n\n// Actions è la keyword per esportare le possibili azioni\n// Quando si scrive questa funzione postAdded e si crea,\n   // slice genera in automatico un'azione \"creator function\" con lo stesso nome della funzione che adda i post\n// Quindi si sta esportando questa azione creator function che è creata automaticamente,\n    // ed è per questo che sopra non si vede la creazione postSlice.action, è automaticamente creata\n   export const { postAdded } = postsSlice.actions;\n\n// Export del reducer\nexport default postsSlice.reducer;"],"mappings":"AAAA;AACA,SAASA,WAAT,EAAsBC,MAAtB,QAAoC,kBAApC;AAIA;AACA,MAAMC,YAAY,GAAG,CACjB;EACIC,EAAE,EAAE,GADR;EACaC,KAAK,EAAE,wBADpB;EAC8CC,OAAO,EAAE;AADvD,CADiB,EAIjB;EACIF,EAAE,EAAE,GADR;EACaC,KAAK,EAAE,WADpB;EACiCC,OAAO,EAAE;AAD1C,CAJiB,CAArB,C,CASA;;AACA,MAAMC,UAAU,GAAGN,WAAW,CAAC;EAC3BO,IAAI,EAAE,OADqB;EAE3BL,YAF2B;EAG3BM,QAAQ,EAAE;IACN;IACAC,SAAS,EAAC;MACNC,OAAO,CAACC,KAAD,EAAQC,MAAR,EAAe;QAClB;QACA;QACA;QACI;QACJD,KAAK,CAACE,IAAN,CAAWD,MAAM,CAACE,OAAlB;MACH,CAPK;;MAQNC,OAAO,CAACX,KAAD,EAAQC,OAAR,EAAgB;QACnB,OAAO;UACHS,OAAO,EAAE;YACLX,EAAE,EAAEF,MAAM,EADL;YAELG,KAFK;YAGLC;UAHK;QADN,CAAP;MAOH;;IAhBK;EAFJ;AAHiB,CAAD,CAA9B,C,CA0BA;AAEA;AACA;;AACA,OAAO,MAAMW,cAAc,GAAIL,KAAD,IAAsBA,KAAK,CAACM,KAAnD,C,CAEP;AACA;AACG;AACH;AACI;;AACD,OAAO,MAAM;EAAER;AAAF,IAAgBH,UAAU,CAACY,OAAjC,C,CAEV;;AACA,eAAeZ,UAAU,CAACI,OAA1B"},"metadata":{},"sourceType":"module"}