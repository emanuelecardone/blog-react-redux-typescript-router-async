{"ast":null,"code":"// nanoid è uno strumento di redux toolkit per generare id random\nimport { createSlice, nanoid, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport axios from \"axios\";\nimport { sub } from \"date-fns\";\nconst POSTS_URL = 'https://jsonplaceholder.typicode.com/posts';\nexport let Status;\n\n(function (Status) {\n  Status[\"IDLE\"] = \"idle\";\n  Status[\"LOADING\"] = \"loading\";\n  Status[\"SUCCEDED\"] = \"succeded\";\n  Status[\"FAILED\"] = \"failed\";\n})(Status || (Status = {}));\n\n// State iniziale (simile al reducer)\nconst initialState = {\n  posts: [],\n  status: Status.IDLE,\n  // 'idle' | 'loading' | 'succeded' | 'failed'\n  error: null\n}; // Fetch per prendere i post\n\nexport const fetchPosts = createAsyncThunk('posts/fetchPosts', async () => {\n  const response = await axios.get(POSTS_URL);\n  const data = response.data;\n  return [...data];\n});\nexport const addNewPost = createAsyncThunk('posts/addNewPost', async initialPost => {\n  try {\n    const response = await axios.post(POSTS_URL, initialPost);\n    return response.data;\n  } catch (err) {\n    if (typeof err === 'string') {\n      return err;\n    } else if (err instanceof Error) {\n      return err.message;\n    }\n  }\n}); // Export slice (oggetto che ha un nome, uno state iniziale, e i reducers che compieranno varie azioni)\n\nconst postsSlice = createSlice({\n  name: 'posts',\n  initialState,\n  reducers: {\n    // questo postAdded ha un reducer e una prepare che è una funzione callback\n    postAdded: {\n      reducer(state, action) {\n        // Action sarà l'azione dispatchata\n        // Payload corrisponderà alle values inserite nelle form\n        // IMPORTANTE: si può usare il push invece di useState solo perché redux toolkit usa una sintassi js,\n        // in tutti gli altri file non-slice però si deve ancora usare useState o l'hook che fa a quel caso\n        state.posts.push(action.payload);\n      },\n\n      prepare(title, body, userId) {\n        return {\n          payload: {\n            id: nanoid(),\n            title,\n            body,\n            userId,\n            date: new Date().toISOString(),\n            reactions: {\n              thumbsUp: 0,\n              wow: 0,\n              heart: 0,\n              rocket: 0,\n              coffee: 0\n            }\n          }\n        };\n      }\n\n    },\n\n    reactionAdded(state, action) {\n      const {\n        postId,\n        reaction\n      } = action.payload;\n      const existingPost = state.posts.find(post => post.id === postId);\n\n      if (existingPost) {\n        existingPost.reactions[reaction]++;\n      }\n    }\n\n  },\n\n  extraReducers(builder) {\n    // Gestione di tutti i casi status tramite builder\n    builder.addCase(fetchPosts.pending, (state, action) => {\n      state.status = Status.LOADING;\n    }).addCase(fetchPosts.fulfilled, (state, action) => {\n      state.status = Status.SUCCEDED; // Data e reazioni\n\n      let min = 1;\n      const loadedPosts = action.payload.map(post => {\n        post.date = sub(new Date(), {\n          minutes: min++\n        }).toISOString();\n        post.reactions = {\n          thumbsUp: 0,\n          wow: 0,\n          heart: 0,\n          rocket: 0,\n          coffee: 0\n        };\n        return post;\n      }); // Aggiunta di ogni post fetchato nell'array\n\n      state.posts = state.posts.concat(loadedPosts);\n    }).addCase(fetchPosts.rejected, (state, action) => {\n      state.status = Status.FAILED;\n      state.error = action.error.message;\n    }) // Case per il nuovo post\n    .addCase(addNewPost.fulfilled, (state, action) => {\n      // Fix per api post id non accurati\n      // Assegnazione id manuale (non sarebbe necessaria se l'api ritornasse id accurati)\n      const sortedPosts = state.posts.sort((a, b) => {\n        if (a.id > b.id) return 1;\n        if (a.id < b.id) return -1;\n        return 0;\n      });\n      action.payload.id = sortedPosts[sortedPosts.length - 1].id + 1;\n      action.payload.userId = Number(action.payload.userId);\n      action.payload.date = new Date().toISOString();\n      action.payload.reactions = {\n        thumbsUp: 0,\n        wow: 0,\n        heart: 0,\n        rocket: 0,\n        coffee: 0\n      };\n      state.posts.push(action.payload);\n    });\n  }\n\n}); // https://redux-toolkit.js.org/usage/usage-with-typescript#createslice\n// In futuro se cambia initialState non avremo più un array e si dovrà cambiare state in ogni componente\n// Quindi si generalizza l'export selezionando tutti i post, così se cambiano i post si dovrà cambiare solo lo slice\n\nexport const selectAllPosts = state => state.posts.posts;\nexport const getPostStatus = state => state.posts.status;\nexport const getPostsError = state => state.posts.error; // Actions è la keyword per esportare le possibili azioni\n// Quando si scrive questa funzione postAdded e si crea,\n// slice genera in automatico un'azione \"creator function\" con lo stesso nome della funzione che adda i post\n// Quindi si sta esportando questa azione creator function che è creata automaticamente,\n// ed è per questo che sopra non si vede la creazione postSlice.action, è automaticamente creata\n\nexport const {\n  postAdded,\n  reactionAdded\n} = postsSlice.actions; // Export del reducer\n\nexport default postsSlice.reducer;","map":{"version":3,"names":["createSlice","nanoid","createAsyncThunk","axios","sub","POSTS_URL","Status","initialState","posts","status","IDLE","error","fetchPosts","response","get","data","addNewPost","initialPost","post","err","Error","message","postsSlice","name","reducers","postAdded","reducer","state","action","push","payload","prepare","title","body","userId","id","date","Date","toISOString","reactions","thumbsUp","wow","heart","rocket","coffee","reactionAdded","postId","reaction","existingPost","find","extraReducers","builder","addCase","pending","LOADING","fulfilled","SUCCEDED","min","loadedPosts","map","minutes","concat","rejected","FAILED","sortedPosts","sort","a","b","length","Number","selectAllPosts","getPostStatus","getPostsError","actions"],"sources":["D:/Programmazione/Repo/react-redux-typescript-async/src/features/posts/postsSlice.tsx"],"sourcesContent":["// nanoid è uno strumento di redux toolkit per generare id random\r\nimport { createSlice, nanoid, PayloadAction, createAsyncThunk } from \"@reduxjs/toolkit\";\r\nimport { RootState } from \"../../app/store\";\r\nimport axios from \"axios\";\r\nimport {sub} from \"date-fns\";\r\n\r\nconst POSTS_URL = 'https://jsonplaceholder.typicode.com/posts';\r\n\r\nexport type Reactions = {\r\n    thumbsUp: number;\r\n    wow: number;\r\n    heart: number;\r\n    rocket: number;\r\n    coffee: number;\r\n}\r\n\r\ntype Post = {\r\n    id: string; \r\n    title: string; \r\n    body: string;\r\n    userId: string;\r\n    date: string;\r\n    reactions: Reactions;\r\n}\r\n\r\ntype InitialPost = {\r\n    title: string;\r\n    body: string;\r\n    userId: string;\r\n}\r\n\r\n// Custom type per payload action\r\ntype PostsPayload = PayloadAction<Post>\r\n\r\n// Custom type per reactions\r\ntype ReactionsPayload = PayloadAction<{\r\n    postId: string;\r\n    reaction: keyof Reactions;\r\n}>\r\n\r\nexport enum Status {\r\n    IDLE = 'idle',\r\n    LOADING = 'loading',\r\n    SUCCEDED = 'succeded',\r\n    FAILED = 'failed'\r\n}\r\n\r\ntype InitialState = {\r\n    posts: Post[];\r\n    status: Status;\r\n    error: unknown | Error;\r\n}\r\n\r\n// State iniziale (simile al reducer)\r\nconst initialState: InitialState = {\r\n    posts: [],\r\n    status: Status.IDLE, // 'idle' | 'loading' | 'succeded' | 'failed'\r\n    error: null\r\n} \r\n\r\n// Fetch per prendere i post\r\nexport const fetchPosts = createAsyncThunk('posts/fetchPosts', async () => {\r\n    const response = await axios.get(POSTS_URL);\r\n    const data: Post[] = response.data;\r\n    return [...data];\r\n})\r\n\r\nexport const addNewPost = createAsyncThunk('posts/addNewPost', async (initialPost: InitialPost) => {\r\n    try {\r\n\r\n        const response = await axios.post(POSTS_URL, initialPost);\r\n        return response.data as Post[];\r\n\r\n    } catch(err: unknown) {\r\n        if(typeof err === 'string'){\r\n            return err;\r\n        } else if (err instanceof Error){\r\n            return err.message;\r\n        }\r\n    }\r\n});\r\n\r\n// Export slice (oggetto che ha un nome, uno state iniziale, e i reducers che compieranno varie azioni)\r\nconst postsSlice = createSlice({\r\n    name: 'posts',\r\n    initialState,\r\n    reducers: {\r\n        // questo postAdded ha un reducer e una prepare che è una funzione callback\r\n        postAdded:{\r\n            reducer(state, action: PostsPayload){\r\n                // Action sarà l'azione dispatchata\r\n                // Payload corrisponderà alle values inserite nelle form\r\n                // IMPORTANTE: si può usare il push invece di useState solo perché redux toolkit usa una sintassi js,\r\n                    // in tutti gli altri file non-slice però si deve ancora usare useState o l'hook che fa a quel caso\r\n                state.posts.push(action.payload);\r\n            },\r\n            prepare(title: string, body: string, userId: string){\r\n                return {\r\n                    payload: {\r\n                        id: nanoid(),\r\n                        title,\r\n                        body,\r\n                        userId,\r\n                        date: new Date().toISOString(),\r\n                        reactions: {\r\n                            thumbsUp: 0,\r\n                            wow: 0,\r\n                            heart: 0,\r\n                            rocket: 0,\r\n                            coffee: 0\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        reactionAdded(state, action: ReactionsPayload){\r\n            const {postId, reaction} = action.payload;\r\n            const existingPost = state.posts.find(post => post.id === postId)\r\n            if(existingPost){\r\n                existingPost.reactions[reaction]++;\r\n            }\r\n        }\r\n    },\r\n    extraReducers(builder){\r\n        // Gestione di tutti i casi status tramite builder\r\n        builder\r\n            .addCase(fetchPosts.pending, (state, action) => {\r\n                state.status = Status.LOADING;\r\n            })\r\n            .addCase(fetchPosts.fulfilled, (state, action) => {\r\n                state.status = Status.SUCCEDED;\r\n                // Data e reazioni\r\n                let min = 1;\r\n                const loadedPosts = action.payload.map((post: Post) => {\r\n                    post.date = sub(new Date(), {minutes: min++}).toISOString();\r\n                    post.reactions = {\r\n                        thumbsUp: 0,\r\n                        wow: 0,\r\n                        heart: 0,\r\n                        rocket: 0,\r\n                        coffee: 0\r\n                    }\r\n                    return post;\r\n                });\r\n\r\n                // Aggiunta di ogni post fetchato nell'array\r\n                state.posts = state.posts.concat(loadedPosts);\r\n            })\r\n            .addCase(fetchPosts.rejected, (state, action) => {\r\n                state.status = Status.FAILED;\r\n                state.error = action.error.message;\r\n            })\r\n            // Case per il nuovo post\r\n            .addCase(addNewPost.fulfilled, (state, action: PayloadAction<any>) => {\r\n\r\n                // Fix per api post id non accurati\r\n                // Assegnazione id manuale (non sarebbe necessaria se l'api ritornasse id accurati)\r\n                const sortedPosts = state.posts.sort((a: Post, b: Post) => {\r\n                    if(a.id > b.id) return 1;\r\n                    if(a.id < b.id) return -1;\r\n                    return 0;\r\n                });\r\n                action.payload.id = sortedPosts[sortedPosts.length - 1].id +1;\r\n\r\n                action.payload.userId = Number(action.payload.userId);\r\n                action.payload.date = new Date().toISOString();\r\n                action.payload.reactions = {\r\n                    thumbsUp: 0,\r\n                    wow: 0,\r\n                    heart: 0,\r\n                    rocket: 0,\r\n                    coffee: 0\r\n                }\r\n                state.posts.push(action.payload);\r\n            })\r\n    }\r\n});\r\n\r\n// https://redux-toolkit.js.org/usage/usage-with-typescript#createslice\r\n\r\n// In futuro se cambia initialState non avremo più un array e si dovrà cambiare state in ogni componente\r\n// Quindi si generalizza l'export selezionando tutti i post, così se cambiano i post si dovrà cambiare solo lo slice\r\nexport const selectAllPosts = (state: RootState) => state.posts.posts;\r\nexport const getPostStatus = (state: RootState) => state.posts.status;\r\nexport const getPostsError = (state: RootState) => state.posts.error;\r\n\r\n// Actions è la keyword per esportare le possibili azioni\r\n// Quando si scrive questa funzione postAdded e si crea,\r\n   // slice genera in automatico un'azione \"creator function\" con lo stesso nome della funzione che adda i post\r\n// Quindi si sta esportando questa azione creator function che è creata automaticamente,\r\n    // ed è per questo che sopra non si vede la creazione postSlice.action, è automaticamente creata\r\n   export const { postAdded, reactionAdded } = postsSlice.actions;\r\n\r\n// Export del reducer\r\nexport default postsSlice.reducer;"],"mappings":"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"},"metadata":{},"sourceType":"module"}