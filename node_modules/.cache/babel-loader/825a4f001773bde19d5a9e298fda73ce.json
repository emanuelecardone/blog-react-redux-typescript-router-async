{"ast":null,"code":"// nanoid è uno strumento di redux toolkit per generare id random\nimport { createSlice, nanoid, createAsyncThunk, createSelector, createEntityAdapter } from \"@reduxjs/toolkit\";\nimport axios from \"axios\";\nimport { sub } from \"date-fns\";\nconst POSTS_URL = 'https://jsonplaceholder.typicode.com/posts';\nexport let Status;\n\n(function (Status) {\n  Status[\"IDLE\"] = \"idle\";\n  Status[\"LOADING\"] = \"loading\";\n  Status[\"SUCCEDED\"] = \"succeded\";\n  Status[\"FAILED\"] = \"failed\";\n  Status[\"PENDING\"] = \"pending\";\n})(Status || (Status = {}));\n\n// State iniziale (simile al reducer)\nconst initialState = {\n  posts: [],\n  status: Status.IDLE,\n  // 'idle' | 'loading' | 'succeded' | 'failed'\n  error: null,\n  // Il count è solo per testare le ottimizzazioni ma è inutile per il blog\n  count: 0\n}; // ENTITY ADAPTER CON TYPESCRIPT\n\nconst postsAdapter = createEntityAdapter({\n  sortComparer: (a, b) => b.date.localeCompare(a.date)\n}); // Fetch per prendere i post (<Post[]> è il return della funzione)\n\nexport const fetchPosts = createAsyncThunk('posts/fetchPosts', async () => {\n  const response = await axios.get(POSTS_URL);\n  const data = response.data;\n  return [...data];\n}); // Quando c'è un parametro va inserito per forza oltre al tipo di ritorno, il tipo del primo argomento che riceve la funzione (initialPost)\n\nexport const addNewPost = createAsyncThunk('posts/addNewPost', async initialPost => {\n  const response = await axios.post(POSTS_URL, initialPost);\n  const data = response.data;\n  return { ...data\n  };\n}); // Update post (il thunk ritorna un post e prende initialEdit come param)\n\nexport const updatePost = createAsyncThunk('posts/updatePost', async initialPost => {\n  const {\n    id\n  } = initialPost;\n  const response = await axios.put(`${POSTS_URL}/${id}`, initialPost);\n  const data = response.data;\n  return { ...data\n  };\n}); // Delete post (ritorna l'oggetto stesso oppure una stringa)\n\nexport const deletePost = createAsyncThunk('post/deletePost', async initialPost => {\n  const {\n    id\n  } = initialPost;\n  const response = await axios.delete(`${POSTS_URL}/${id}`); // json placeholder con le request delete non ritorna l'id come dovrebbe fare una rest api, quindi si ritorna l'oggetto stesso in questo caso\n\n  if ((response === null || response === void 0 ? void 0 : response.status) === 200) return initialPost;\n  return `${response === null || response === void 0 ? void 0 : response.status}: ${response === null || response === void 0 ? void 0 : response.statusText}`;\n}); // Export slice (oggetto che ha un nome, uno state iniziale, e i reducers che compieranno varie azioni)\n// i reducer e extraReducer qui sotto saranno runnati SOLO nel createSlice in questo caso postsSlice\n\nconst postsSlice = createSlice({\n  name: 'posts',\n  initialState,\n  reducers: {\n    // questo postAdded ha un reducer e una prepare che è una funzione callback\n    postAdded: {\n      reducer(state, action) {\n        // Action sarà l'azione dispatchata\n        // Payload corrisponderà alle values inserite nelle form\n        // IMPORTANTE: si può usare il push invece di useState solo perché redux toolkit usa una sintassi js,\n        // in tutti gli altri file non-slice però si deve ancora usare useState o l'hook che fa a quel caso\n        state.posts.push(action.payload);\n      },\n\n      prepare(title, body, userId) {\n        return {\n          payload: {\n            id: nanoid(),\n            title,\n            body,\n            userId,\n            date: new Date().toISOString(),\n            reactions: {\n              thumbsUp: 0,\n              wow: 0,\n              heart: 0,\n              rocket: 0,\n              coffee: 0\n            }\n          }\n        };\n      }\n\n    },\n\n    reactionAdded(state, action) {\n      const {\n        postId,\n        reaction\n      } = action.payload;\n      const existingPost = state.posts.find(post => post.id === postId);\n\n      if (existingPost) {\n        existingPost.reactions[reaction]++;\n      }\n    },\n\n    // Non prende nessuna action in quanto agisce sul count dello state senza bisogno di parametri\n    increaseCount(state) {\n      state.count = state.count + 1;\n    }\n\n  },\n\n  extraReducers(builder) {\n    // Gestione di tutti i casi status tramite builder\n    builder.addCase(fetchPosts.pending, (state, action) => {\n      state.status = Status.LOADING;\n    }).addCase(fetchPosts.fulfilled, (state, action) => {\n      state.status = Status.SUCCEDED; // Data e reazioni\n\n      let min = 1;\n      const loadedPosts = action.payload.map(post => {\n        post.date = sub(new Date(), {\n          minutes: min++\n        }).toISOString();\n        post.reactions = {\n          thumbsUp: 0,\n          wow: 0,\n          heart: 0,\n          rocket: 0,\n          coffee: 0\n        };\n        return post;\n      }); // Aggiunta di ogni post fetchato nell'array\n\n      state.posts = state.posts.concat(loadedPosts);\n    }).addCase(fetchPosts.rejected, (state, action) => {\n      state.status = Status.FAILED;\n      state.error = action.error.message;\n    }) // Case per il nuovo post\n    .addCase(addNewPost.fulfilled, (state, action) => {\n      // Fix per api post id non accurati\n      // Assegnazione id manuale (non sarebbe necessaria se l'api ritornasse id accurati)\n      const sortedPosts = state.posts.sort((a, b) => {\n        if (a.id > b.id) return 1;\n        if (a.id < b.id) return -1;\n        return 0;\n      });\n      action.payload.id = sortedPosts[sortedPosts.length - 1].id + 1;\n      action.payload.userId = Number(action.payload.userId);\n      action.payload.date = new Date().toISOString();\n      action.payload.reactions = {\n        thumbsUp: 0,\n        wow: 0,\n        heart: 0,\n        rocket: 0,\n        coffee: 0\n      };\n      state.posts.push(action.payload);\n    }) // Case per edit post\n    .addCase(updatePost.fulfilled, (state, action) => {\n      var _action$payload;\n\n      // Se il payload non ha alcun id allora non verrà completato l'update\n      if (!((_action$payload = action.payload) !== null && _action$payload !== void 0 && _action$payload.id)) {\n        console.log('Update could not complete');\n        console.log(action.payload);\n        return;\n      }\n\n      const {\n        id\n      } = action.payload;\n      action.payload.date = new Date().toISOString();\n      const posts = state.posts.filter(post => post.id !== id);\n      state.posts = [...posts, action.payload];\n    }).addCase(deletePost.fulfilled, (state, action) => {\n      // Controllo runtime per debug nel caso si torni la stringa con il codice status\n      if (typeof action.payload !== 'string') {\n        var _action$payload2;\n\n        if (!((_action$payload2 = action.payload) !== null && _action$payload2 !== void 0 && _action$payload2.id)) {\n          console.log('Delete could not complete');\n          console.log(action.payload);\n          return;\n        }\n\n        const {\n          id\n        } = action.payload;\n        const posts = state.posts.filter(post => post.id !== id); // Non si usa lo spread perché non si vuole più quel post anche nell'array originale\n\n        state.posts = posts;\n      } else {\n        console.log(action.payload);\n      }\n    });\n  }\n\n}); // https://redux-toolkit.js.org/usage/usage-with-typescript#createslice\n// In futuro se cambia initialState non avremo più un array e si dovrà cambiare state in ogni componente\n// Quindi si generalizza l'export selezionando tutti i post, così se cambiano i post si dovrà cambiare solo lo slice\n\nexport const selectAllPosts = state => state.posts.posts;\nexport const getPostStatus = state => state.posts.status;\nexport const getPostsError = state => state.posts.error; // Selettore per il test count (si deve far riferimento a state.posts perché i reducers avvengono SOLO in postsSlice altrimenti bisogna creare un altro slice)\n\nexport const selectCount = state => state.posts.count;\nexport const selectPostById = (state, postId) => state.posts.posts.find(post => post.id === postId); // Spiegazione sul createSelector su appunti o documentazione\n// In breve: prende una inputSelector e solo se questa cambia avviene la resultFunction\n// il primo inputSelector ritorna ciò che è il primo parametro della resultFunction, il secondo ritorna il secondo parametro e così via se ci fossero altri selettori\n\nexport const selectPostsByUser = createSelector( // inputSelectors (come array)\n[selectAllPosts, (state, userId) => userId], // resultFunction\n(posts, userId) => posts.filter(post => post.userId === userId)); // Actions è la keyword per esportare le possibili azioni\n// Quando si scrive questa funzione postAdded e si crea,\n// slice genera in automatico un'azione \"creator function\" con lo stesso nome della funzione che adda i post\n// Quindi si sta esportando questa azione creator function che è creata automaticamente,\n// ed è per questo che sopra non si vede la creazione postSlice.action, è automaticamente creata\n\nexport const {\n  postAdded,\n  reactionAdded,\n  increaseCount\n} = postsSlice.actions; // Export del reducer\n\nexport default postsSlice.reducer;","map":{"version":3,"names":["createSlice","nanoid","createAsyncThunk","createSelector","createEntityAdapter","axios","sub","POSTS_URL","Status","initialState","posts","status","IDLE","error","count","postsAdapter","sortComparer","a","b","date","localeCompare","fetchPosts","response","get","data","addNewPost","initialPost","post","updatePost","id","put","deletePost","delete","statusText","postsSlice","name","reducers","postAdded","reducer","state","action","push","payload","prepare","title","body","userId","Date","toISOString","reactions","thumbsUp","wow","heart","rocket","coffee","reactionAdded","postId","reaction","existingPost","find","increaseCount","extraReducers","builder","addCase","pending","LOADING","fulfilled","SUCCEDED","min","loadedPosts","map","minutes","concat","rejected","FAILED","message","sortedPosts","sort","length","Number","console","log","filter","selectAllPosts","getPostStatus","getPostsError","selectCount","selectPostById","selectPostsByUser","actions"],"sources":["/Users/emanuelecardone/Desktop/Corsi /Redux/Esempi/react-redux-typescript-async/src/features/posts/postsSlice.tsx"],"sourcesContent":["// nanoid è uno strumento di redux toolkit per generare id random\nimport { \n    createSlice, \n    nanoid, \n    PayloadAction, \n    createAsyncThunk, \n    createSelector, \n    createEntityAdapter \n} from \"@reduxjs/toolkit\";\nimport { RootState } from \"../../app/store\";\nimport axios from \"axios\";\nimport {sub} from \"date-fns\";\n\nconst POSTS_URL = 'https://jsonplaceholder.typicode.com/posts';\n\nexport type Reactions = {\n    thumbsUp: number;\n    wow: number;\n    heart: number;\n    rocket: number;\n    coffee: number;\n}\n\nexport type Post = {\n    id: string; \n    title: string; \n    body: string;\n    userId: string | number;\n    date: string;\n    reactions: Reactions;\n}\n\n// Aggiunta post\ntype InitialPost = {\n    title: string;\n    body: string;\n    userId: string | number;\n}\n\n// Modifica post\ntype InitialEdit = {\n    id: string;\n    title: string;\n    body: string;\n    userId: string | number;\n    reactions: Reactions;\n}\n\n// Delete post \ntype InitialDelete = {\n    id: string;\n}\n\n// Custom type per payload action\ntype PostsPayload = PayloadAction<Post>\n\n// Custom type per reactions\ntype ReactionsPayload = PayloadAction<{\n    postId: string;\n    reaction: keyof Reactions;\n}>\n\nexport enum Status {\n    IDLE = 'idle',\n    LOADING = 'loading',\n    SUCCEDED = 'succeded',\n    FAILED = 'failed',\n    PENDING = 'pending'\n}\n\ntype InitialState = {\n    posts: Post[];\n    status: Status;\n    error: unknown | Error;\n    count: number;\n}\n\n// State iniziale (simile al reducer)\nconst initialState: InitialState = {\n    posts: [],\n    status: Status.IDLE, // 'idle' | 'loading' | 'succeded' | 'failed'\n    error: null,\n    // Il count è solo per testare le ottimizzazioni ma è inutile per il blog\n    count: 0\n} \n\n// ENTITY ADAPTER CON TYPESCRIPT\nconst postsAdapter = createEntityAdapter({\n    sortComparer: (a: Post, b: Post) => b.date.localeCompare(a.date)\n});\n\n// Fetch per prendere i post (<Post[]> è il return della funzione)\nexport const fetchPosts = createAsyncThunk<Post[]>('posts/fetchPosts', async () => {\n    const response = await axios.get(POSTS_URL);\n    const data: Post[] = response.data;\n    return [...data];\n})\n\n// Quando c'è un parametro va inserito per forza oltre al tipo di ritorno, il tipo del primo argomento che riceve la funzione (initialPost)\nexport const addNewPost = createAsyncThunk<Post, InitialPost>('posts/addNewPost', async (initialPost) => {\n    const response = await axios.post(POSTS_URL, initialPost);\n    const data: Post = response.data;\n    return {...data};\n});\n\n// Update post (il thunk ritorna un post e prende initialEdit come param)\nexport const updatePost = createAsyncThunk<Post, InitialEdit>('posts/updatePost', async (initialPost) => {\n    const { id } = initialPost; \n    const response = await axios.put(`${POSTS_URL}/${id}`, initialPost);\n    const data: Post = response.data;\n    return {...data};\n});\n\n// Delete post (ritorna l'oggetto stesso oppure una stringa)\nexport const deletePost = createAsyncThunk<InitialDelete | string, InitialDelete>('post/deletePost', async (initialPost) => {\n    const { id } = initialPost;\n    const response = await axios.delete(`${POSTS_URL}/${id}`);\n    // json placeholder con le request delete non ritorna l'id come dovrebbe fare una rest api, quindi si ritorna l'oggetto stesso in questo caso\n    if(response?.status === 200) return initialPost;\n    return `${response?.status}: ${response?.statusText}`;\n});\n\n// Export slice (oggetto che ha un nome, uno state iniziale, e i reducers che compieranno varie azioni)\n// i reducer e extraReducer qui sotto saranno runnati SOLO nel createSlice in questo caso postsSlice\nconst postsSlice = createSlice({\n    name: 'posts',\n    initialState,\n    reducers: {\n        // questo postAdded ha un reducer e una prepare che è una funzione callback\n        postAdded:{\n            reducer(state, action: PostsPayload){\n                // Action sarà l'azione dispatchata\n                // Payload corrisponderà alle values inserite nelle form\n                // IMPORTANTE: si può usare il push invece di useState solo perché redux toolkit usa una sintassi js,\n                    // in tutti gli altri file non-slice però si deve ancora usare useState o l'hook che fa a quel caso\n                state.posts.push(action.payload);\n            },\n            prepare(title: string, body: string, userId: string | number){\n                return {\n                    payload: {\n                        id: nanoid(),\n                        title,\n                        body,\n                        userId,\n                        date: new Date().toISOString(),\n                        reactions: {\n                            thumbsUp: 0,\n                            wow: 0,\n                            heart: 0,\n                            rocket: 0,\n                            coffee: 0\n                        }\n                    }\n                }\n            }\n        },\n        reactionAdded(state, action: ReactionsPayload){\n            const {postId, reaction} = action.payload;\n            const existingPost = state.posts.find(post => post.id === postId)\n            if(existingPost){\n                existingPost.reactions[reaction]++;\n            }\n        },\n        // Non prende nessuna action in quanto agisce sul count dello state senza bisogno di parametri\n        increaseCount(state){\n            state.count = state.count +1;\n        }\n    },\n    extraReducers(builder){\n        // Gestione di tutti i casi status tramite builder\n        builder\n            .addCase(fetchPosts.pending, (state, action) => {\n                state.status = Status.LOADING;\n            })\n            .addCase(fetchPosts.fulfilled, (state, action) => {\n                state.status = Status.SUCCEDED;\n                // Data e reazioni\n                let min = 1;\n                const loadedPosts = action.payload.map((post: Post) => {\n                    post.date = sub(new Date(), {minutes: min++}).toISOString();\n                    post.reactions = {\n                        thumbsUp: 0,\n                        wow: 0,\n                        heart: 0,\n                        rocket: 0,\n                        coffee: 0\n                    }\n                    return post;\n                });\n\n                // Aggiunta di ogni post fetchato nell'array\n                state.posts = state.posts.concat(loadedPosts);\n            })\n            .addCase(fetchPosts.rejected, (state, action) => {\n                state.status = Status.FAILED;\n                state.error = action.error.message;\n            })\n            // Case per il nuovo post\n            .addCase(addNewPost.fulfilled, (state, action) => {\n                \n                // Fix per api post id non accurati\n                // Assegnazione id manuale (non sarebbe necessaria se l'api ritornasse id accurati)\n                const sortedPosts = state.posts.sort((a: Post, b: Post) => {\n                    if(a.id > b.id) return 1;\n                    if(a.id < b.id) return -1;\n                    return 0;\n                });\n                action.payload.id = sortedPosts[sortedPosts.length - 1].id +1;\n\n                action.payload.userId = Number(action.payload.userId);\n                action.payload.date = new Date().toISOString();\n                action.payload.reactions = {\n                    thumbsUp: 0,\n                    wow: 0,\n                    heart: 0,\n                    rocket: 0,\n                    coffee: 0\n                }\n                state.posts.push(action.payload);\n            })\n            // Case per edit post\n            .addCase(updatePost.fulfilled, (state, action) => {\n                // Se il payload non ha alcun id allora non verrà completato l'update\n                if(!action.payload?.id){\n                    console.log('Update could not complete');\n                    console.log(action.payload);\n                    return;\n                }\n                const { id } = action.payload;\n                action.payload.date = new Date().toISOString();\n                const posts = state.posts.filter(post => post.id !== id);\n                state.posts = [...posts, action.payload];\n            })\n            .addCase(deletePost.fulfilled, (state,action) => {\n                // Controllo runtime per debug nel caso si torni la stringa con il codice status\n                if(typeof action.payload !== 'string'){\n                    if(!action.payload?.id){\n                        console.log('Delete could not complete');\n                        console.log(action.payload);\n                        return;\n                    }\n                    const { id } = action.payload;\n                    const posts = state.posts.filter(post => post.id !== id);\n                    // Non si usa lo spread perché non si vuole più quel post anche nell'array originale\n                    state.posts = posts;\n                } else{\n                    console.log(action.payload);\n                }\n            });\n    }\n});\n\n// https://redux-toolkit.js.org/usage/usage-with-typescript#createslice\n\n// In futuro se cambia initialState non avremo più un array e si dovrà cambiare state in ogni componente\n// Quindi si generalizza l'export selezionando tutti i post, così se cambiano i post si dovrà cambiare solo lo slice\nexport const selectAllPosts = (state: RootState) => state.posts.posts;\nexport const getPostStatus = (state: RootState) => state.posts.status;\nexport const getPostsError = (state: RootState) => state.posts.error;\n\n// Selettore per il test count (si deve far riferimento a state.posts perché i reducers avvengono SOLO in postsSlice altrimenti bisogna creare un altro slice)\nexport const selectCount = (state: RootState) => state.posts.count;\n\nexport const selectPostById = (state: RootState, postId: number | string) => state.posts.posts.find(post => post.id === postId);\n\n// Spiegazione sul createSelector su appunti o documentazione\n// In breve: prende una inputSelector e solo se questa cambia avviene la resultFunction\n    // il primo inputSelector ritorna ciò che è il primo parametro della resultFunction, il secondo ritorna il secondo parametro e così via se ci fossero altri selettori\nexport const selectPostsByUser = createSelector(\n    // inputSelectors (come array)\n    [\n        selectAllPosts, \n        (state, userId) => userId\n    ],\n    // resultFunction\n    (posts, userId) => posts.filter(post => post.userId === userId)\n);\n\n// Actions è la keyword per esportare le possibili azioni\n// Quando si scrive questa funzione postAdded e si crea,\n   // slice genera in automatico un'azione \"creator function\" con lo stesso nome della funzione che adda i post\n// Quindi si sta esportando questa azione creator function che è creata automaticamente,\n    // ed è per questo che sopra non si vede la creazione postSlice.action, è automaticamente creata\n   export const { postAdded, reactionAdded, increaseCount } = postsSlice.actions;\n\n// Export del reducer\nexport default postsSlice.reducer;"],"mappings":"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"},"metadata":{},"sourceType":"module"}